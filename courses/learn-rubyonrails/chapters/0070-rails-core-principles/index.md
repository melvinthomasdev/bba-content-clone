Before we start to learn the Ruby on Rails, let's first go through the
philosophies behind it.

Ruby on Rails is a `Ruby` language based web application development framework.
It's commonly referred as `Rails`, and often abbreviated as `RoR`.

Rails is an opinionated web development framework designed to be expressive, fun
to work with and in turn make the web development process easier.

Rails does a lot of functionalities out of the box for us, such that we don't
have to worry about the configuration part nor code it by ourselves, in most
cases.

This is achieved by enforcing some strict conventions in place.

Rails philosophy includes two core principles:

## DRY

Don't Repeat Yourself(DRY) is a software development principle which states
that:

"Every piece of knowledge must have a single, unambiguous, authoritative
representation within a system".

In short, **don't write** repetitive code.

This ensures maintainability, extensibility of the code, and makes it easier to
debug.

We will be looking at how Rails makes our code DRY in upcoming chapters.

## Convention over configuration

Rails utilizes the dynamism of Ruby language to make developer's lives easier.

It uses a default set of conventions by making the assumption that we are
sticking onto the advocated practices. If we follow the conventions, then we
don't have to configure a lot of things on our own. Rails magically handles a
lot of cases for us.

Configurations and practices can change from developer to developer based on
personal interests. Thus when working in a team, it becomes hard to review and
keep track of the different practices followed. That's why the Rails principle
of **convention over configuration** is widely accepted.

You can read more on this in the official
[Rails page](https://rubyonrails.org/doctrine/#convention-over-configuration).

However, at the same time, Rails doesn't restrict us to configure the
applications in our own custom way, if needed.

To understand the Rails framework properly, we need to keep these two principles
in mind. Moreover, sticking onto these principles will make you a better
programmer.
