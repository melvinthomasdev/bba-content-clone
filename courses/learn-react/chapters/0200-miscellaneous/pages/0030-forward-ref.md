
In the lesson on the [useRef hook](/learn-react/side-effects/use-ref-hook/), we became acquainted with how Refs in React can reference a DOM element within the render method. However, in React component interactions, there are instances where accessing or controlling the underlying DOM nodes generated by a child component becomes necessary. Although passing a `ref` as a prop to a child component might appear logical, it often doesn't produce the expected results. This lesson will delve into why the latter method falls short and how we can manage such scenarios effectively through Ref forwarding using `forwardRef`.

Let's delve into understanding Ref forwarding's behavior by creating a simple form comprising a field and a button that focuses on that field.

<codeblock language="reactjs" type="lesson">
<code>
import React, { useRef } from 'react';

const Form = () => {
  const inputRef = useRef(null);

  const handleClick = () => {
    if (inputRef.current) {
      inputRef.current.focus(); 
    }
  };

  return (
    <div className="flex">
      <input ref={inputRef} />
      <button onClick={handleClick}>Edit</button>
    </div>
  );
};

export default Form;
</code>
</codeblock>

Now, suppose we want to tailor the behavior of the input element to incorporate a label and display error messages with appropriate styling. To achieve this, we'll create a custom component called `InputField`. However, we encounter a challenge: we can no longer directly reference the input element.

<codeblock language="reactjs" type="lesson">
<code>
import React, { useState, useRef } from 'react';

const InputField = (
    {
      type = "text",
      label,
      placeholder,
      isRequired,
      ref,
      ...rest
    }
  ) => {
    const [value, setValue] = useState("");

    return (
      <div>
        {label && (
          <label>
            {label}
          </label>
        )}
        <input
          value={value}
          type={type}
          placeholder={placeholder}
          onChange={e => setValue(e.target.value)}
          ref={ref}
          {...rest}
        />
        {(isRequired && value === "") && 
          <i> Required field </i>
        }
      </div>
    )
  };

const Form = () => {
  const inputRef = useRef(null);

  const handleClick = () => {
    if (inputRef.current) {
      inputRef.current.focus(); 
    }
  };

  return (
    <div>
      <InputField isRequired ref={inputRef} label="Name: "/>
      <button onClick={handleClick}>Edit</button>
    </div>
  );
};


export default Form;
</code>
</codeblock>

In the above example, refs will not get passed through. This is because `ref` is not a prop. Like `key`, itâ€™s handled differently by React. Consequently, the input field will no longer be focused as intended.

Luckily, React offers `forwardRef` for transferring refs from a parent component to a child. Essentially, it enables a component to expose a DOM node to its parent component with a Ref. 

When you use `forwardRef`, React knows that the component expects a `ref` and automatically handles it. However, if you pass a Ref directly to a functional component without using `forwardRef`, React won't recognize it as a valid reference.

The `forwardRef` function takes a render function as an argument. React calls this function with `props` and `ref`. `forwardRef` returns a React component that can be rendered in JSX. Notably, unlike components defined as regular functions, a component returned by `forwardRef` can also accept a `ref` prop.

<codeblock language="reactjs" type="lesson">
<code>
import React, { useState, useRef, forwardRef } from 'react';

const InputField = forwardRef(
  (
    {
      type = "text",
      label,
      placeholder,
      isRequired,
      ...rest
    },
    ref
  ) => {
    const [value, setValue] = useState("");

    return (
      <div>
        {label && (
          <label>
            {label}
          </label>
        )}
        <input
          value={value}
          ref={ref}
          type={type}
          placeholder={placeholder}
          onChange={e => setValue(e.target.value)}
          {...rest}
        />
        {(isRequired && value === "") && 
          <i> Required field </i>
        }
      </div>
    )
  }
);

const Form = () => {
  const inputRef = useRef(null);

  const handleClick = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div className="flex">
      <InputField isRequired ref={inputRef} label="Name: "/>
      <button onClick={handleClick}>Edit</button>
    </div>
  );
};

export default Form;
</code>
</codeblock>

When you expose a Ref, it means that the internal implementation details of your component become accessible from the outside. This has implications for the flexibility and maintainability of your component.

If external component code is relying on the internal component structure exposed through the Ref, any changes to that structure might break existing functionality in the external code.

As a best practice, we can choose to expose Refs from components that are low-level and reusable, such as buttons or text inputs. These components are less likely to undergo major structural changes over time and are designed to be used in various contexts.

On the other hand, for higher-level or application-specific components like profile or dashboard, it's generally better to keep the internal implementation details hidden. These components are more likely to evolve in terms of structure and behavior as the application develops, and exposing Refs from them could lead to more maintenance challenges and potential compatibility issues with external code.

